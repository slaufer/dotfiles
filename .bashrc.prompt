# accepts a series of 4-part section definitions
# _PROMPT_RENDER [fg1 bg1 sep1 text1 [fg2 bg2 sep2 text2 ...]]
# fgN: foreground color (-1 for terminal default)
# bgN: background color (-1 for terminal default)
# sepN: 1 to include powerline-style separator, 0 for no separator
# textN: text to display in the section
_PROMPT_RENDER() {
  local sections=("$@")
  local prompt=""

  for ((i = 0; i < ${#sections[@]}; i+=4)); do
    fg=${sections[i]}
    bg=${sections[i+1]}
    sep=${sections[i+2]}
    text="${sections[i+3]}"

    if ((sep > 0)); then
      prevbg=${sections[i-3]}
      if ((bg >= 0 && prevbg >= 0)); then
        prompt+="\[\e[38;5;${prevbg};48;5;${bg}m\]\ue0b0"
      elif ((prevbg >= 0)); then
        prompt+="\[\e[0m\e[38;5;${prevbg}m\]\ue0b0"
      elif ((bg >= 0)); then
        prompt+="\[\e[0m\e[38;5;${bg}m\e[7m\]\ue0b0\[\e[27m\]"
      else
        prompt+=" "
      fi
    fi

    if ((bg >= 0 && fg >= 0)); then
      prompt+="\[\e[38;5;${fg};48;5;${bg}m\]"
    elif ((bg >= 0)); then
      prompt+="\[\e[0m\e[48;5;${bg}m\]"
    elif ((fg >= 0)); then
      prompt+="\[\e[0m\e[38;5;${fg}m\]"
    else
      prompt+="\[\e[0m\]"
    fi

    prompt+="$text"
  done

  echo "$prompt"
}

_PROMPT_COMMAND() {
	# grab exit code while we can
	local exit=$?
  local prompt_mtime=$(($(date +%s%N) / 1000000))
  local sections=()

  if ((_PROMPT_EXEC_START != 0)); then
    local dur=$((prompt_mtime - _PROMPT_EXEC_START))

    if ((exit > 0)); then
      sections+=(0 160 0 "$exit")
    else
      sections+=(0 34 0 "$exit")
    fi

    sections+=(45 25 1 "${dur}ms")
    sections+=(-1 -1 1 "\n")
  fi

	# TODO: make this dynamic?
	local DIR_WIDTH=60
	
	# status line clock
  sections+=(0 45 0 "$(date '+%-l:%M%P')")

	# status line working directory
	local dir=$(dirs +0)
	(( ${#dir} > DIR_WIDTH )) && dir=...${dir: $((3 - DIR_WIDTH))}
  sections+=(0 39 1 "$dir")

	# fun fact: "local" has an exit code
	local git_status
  git_status=$(git status -s 2> /dev/null)
  local git_exit=$?

	if (( git_exit == 0 )); then
		# figure out status counts
		local unstaged=$(grep -E '^.[MADRC?]' -c <<< "$git_status")
		local staged=$(grep '^[MADRC]' -c <<< "$git_status")
    local branch="$(git rev-parse --abbrev-ref HEAD)"
    sections+=(-1 -1 1 " ")
    sections+=(0 245 1 "${branch}")
    (( unstaged )) && sections+=(0 160 1 "${unstaged}")
    (( staged )) && sections+=(0 34 1 "${staged}")
	fi

  # line break, command count, user@host
  sections+=(-1 -1 1 "\n")
  sections+=(0 45 0 "#\#")
  sections+=(0 39 1 "\u@\h")

  # venv (if applicable)
  if [[ ! -z "$VIRTUAL_ENV_PROMPT" ]]; then
    sections+=(0 25 1 $VIRTUAL_ENV_PROMPT)
  fi

  # previous exit code (if applicable), command prompt
  sections+=(45 -1 1 " \$ ")
  sections+=(-1 -1 0 "")

	local title_reset="\[\033]0;$USER@${HOSTNAME} $(pwd)\007\]"
  local prompt="$(_PROMPT_RENDER "${sections[@]}")"
  PS1="$(echo -e "\n${title_reset}${prompt}")"

  history -a
  history -n

  _PROMPT_PREEXEC_READY=1
}

_PROMPT_PREEXEC_READY=0
_PROMPT_EXEC_START=0

_PROMPT_PREEXEC() {
  ((_PROMPT_PREEXEC_READY == 0)) && return
  [[ "$BASH_COMMAND" == "_PROMPT_COMMAND" ]] && return
  _PROMPT_PREEXEC_READY=0
  _PROMPT_EXEC_START=$(($(date +%s%N) / 1000000))
  echo -ne "\033]0;$BASH_COMMAND $USER@${HOSTNAME} $(pwd)\007"
  local time=$(date '+%-l:%M%P')
  time=$time
  echo -e "\e[38;5;0;48;5;34m${time}\e[38;5;34;48;5;25m\ue0b0\e[38;5;45;48;5;25m${BASH_COMMAND}\e[0m\e[38;5;25m\ue0b0\e[0m\n"
}

PROMPT_COMMAND="_PROMPT_COMMAND"
trap "_PROMPT_PREEXEC" DEBUG
